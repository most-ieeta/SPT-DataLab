/*
----
This file is part of SECONDO.

Copyright (C) 2004, University in Hagen, Department of Computer Science,
Database Systems for New Applications.

SECONDO is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

SECONDO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SECONDO; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
----

Scanner for the ListExpr class.

March, 1999. Jose Antonio Cotelo Lema.

June 1999: added to the package sj.lang.JavaListExpr

August 1999: changed the grammar for <symbolAthom>. Now either starts with a letter, followed only by letters, digits or underline characters, or contains only other characters (e.g. mathematic characters, dots, colons, etc..).

This file is an input file for the Java Lexical Analizer Generator JLEX.
The output file generated by JLEX will be a .java file defining a class NLTokenizer that will be an scaner for nested lists.

The initial state is YYINITIAL.
The lexical rules are in the form [<state>] <expression> {<action>}, where
the <state> is optional (in this case this rule is valid in any states),
<expression> is a lexical rule with almost the same syntaxis than is used
in Lex, and <action> is a block of Java code.



The tokens accepted by this scanner follow the following rules:

        <boolAtom> =        { 'TRUE' | 'FALSE' }

        <intAtom> =        <sign> <number>

        <sign> =        ['-']  // This includes the option of having no sign.


        <realAtom> =        <sign> <number> '.' <number>
                |        <sign> <number> '.' <number> <exponent>
                |        <sign> <number> <exponent>

        <stringAtom> =        '"' <characterSeq> '"'

        <symbolAtom> =        <letter> {<letter> | <digit> | <underline>}*
                |        <otherChar> {<otherChar>}*

        <textAtom> =        '<' text '>' {<anyChar>}* '<' '\' text '-' '-' '-' '>'

Where:

        <number> =        <digit> {<digit>}*
        <exponent> =        'E' <sign> <number>
        <characterSeq> =        <stringCharacter> <characterSeq>
                |
        <anyChar> =        <any possible character>
        <letter> =        'A'-'Z'
                |        'a'-'z'
        <digit> =        '0'-'9'
        <stringCharacter> =        <any character except the doble quote
                                 character>
        <underline> =        <The underline character '_'>
        <otherChar> =        <any character which is neither a <letter> nor a
                         <digit> nor a '"', '(' or ')'>

*/

package sj.lang.JavaListExpr;
import java_cup10.runtime.*;
import sj.lang.ListExpr;
import java.io.*;
import tools.Base64Encoder;
import tools.Reporter;

class NLToken extends Symbol implements NLSymbol{
  // It extends the Symbol class to allow return the line and character where
  // the scanner is reading.

  /* Variables. */
  // This variable returns the number of character of the first character on
  // this token. It considers the first character as character 1.
  public int charPos;
  // This variable returns the number of line of the first character on
  // this token. It considers the first line as line 1.
  public int linePos;

  /* Class Constructor */
  public NLToken(int type, Object value,int charPos, int linePos){
    super(type);

    this.value = value;
    this.charPos = charPos;
    this.linePos = linePos;
  }
}






%%
%class NLTokenizer

%function nextToken


%type NLToken


%unicode

%char

%line



%eofval{
  // If it detects the end of file (EOF) returns the EOF token.
  return(new NLToken(NLToken.EOF, null, yychar+1, yyline+1));
%eofval}

%{
  // Code for the NLTokenizer class, defining internal variables.
  // The textContent variable stores the part of the textAtom that has been
  // read. It is used only when a textAtom is being parsed.
  private StringBuffer textContent = new StringBuffer();


  // Defines if the class must show extra information when errors are detected.
  private static final boolean DEBUG_MODE = true;
%}

%state TEXTATOM_STATE
%state TEXTATOM_SIMPLE
%state COMMENT_STATE




otherChar   =   [^\(\)\"A-Za-z0-9_" "\'\b\f\n\r\t]
letter      =   [a-zA-Z]
digit       =   [0-9]
ident       =   {letter}({letter}|{digit}|_)*
math        =   {otherChar}{otherChar}*
symbol      =   {math}|{ident}
string      =   \"([^\"]|\\\")*\"
filename    =   "<file>".*"</file--->"
commentstart =  "_!"
commentend   =  "!_"
double_bs    = \\\\
num1        =  [-+]?{digit}+\.?([eE][-+]?{digit}+)?
num2        =  [-+]?{digit}*\.{digit}+([eE][-+]?{digit}+)?
number      =    {num1}|{num2}



%%



<YYINITIAL> [" "\b\f\n\r\t]+       {}

<YYINITIAL> -?[0-9]+       {
                  // The token is an ~intAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  try{
                    value = ListExpr.intAtom(Integer.valueOf(yytext()).intValue());
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing an integer number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_INT_ATOM, value, yychar+1,
                         yyline+1));
                }

<YYINITIAL> {number} {
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                       Reporter.writeError("try to create a double value from " + yytext());
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }

<YYINITIAL> "TRUE" {
                  // The token is a ~boolAtom~.
                  return(new NLToken(NLToken.TT_BOOL_ATOM,
                         ListExpr.boolAtom(true), yychar+1, yyline+1));
               }

<YYINITIAL> "FALSE" {
                  // The token is a ~boolAtom~.
                  return(new NLToken(NLToken.TT_BOOL_ATOM,
                         ListExpr.boolAtom(false), yychar+1, yyline+1));
               }

<YYINITIAL> {string} {
                  // If it finds an ~stringAtom~, it returns its content,
                  // without the doble quotes at the start and end.
                  String s = yytext().substring(1,yytext().length()-1);
                  s = ListExpr.replaceAll(s,"\\\"","\"");
                  s = ListExpr.replaceAll(s,"\\\\","\\");
                  return(new NLToken(NLToken.TT_STRING_ATOM,
                         ListExpr.stringAtom(s),
                         yychar+1, yyline+1));
                }


<YYINITIAL> {filename} {
                     // first extract the real filename
                     String FNWithTags = yytext();
                     String FN = FNWithTags.substring(6,FNWithTags.length()-10).trim();
                     try{
                        String Directory = ListExpr.getDirectory();
                        String fn = null;
                        if(!FN.startsWith(File.separator)){
                           if(Directory==null){
                              Reporter.writeError("Directory shound not be null");
                           }
                           if(!Directory.endsWith(File.separator)){
                               Directory += File.separatorChar;
                           }
                           fn = Directory + FN;
                        } else {
                           fn = FN;
                        }

                        File F = new File(fn);

                        long size = F.length();
                        long encodedSize = Base64Encoder.getEncodedSize(size);
                        BufferedInputStream in = new BufferedInputStream(new FileInputStream(F));
                        Base64Encoder Enc = new Base64Encoder(in);
                        StringBuffer Content = new StringBuffer((int)encodedSize+1);
                        int next;
                        while( (next = Enc.getNext())>=0)
                               Content.append((char)next);
                        in.close();
                        return( new NLToken(NLToken.TT_TEXT_ATOM,
                                ListExpr.textAtom(Content.toString()),
                                yychar+1,yyline+1));
                     } catch(Exception e){
                        if(DEBUG_MODE){
                            Reporter.writeError("error in reading binary data from file");
                                              Reporter.debug(e);
                        }
                         return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                     }

                }

<YYINITIAL> {symbol} {
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }

<YYINITIAL> {commentstart} {
                            yybegin(COMMENT_STATE);
                           }
<COMMENT_STATE> {commentend} {
                             yybegin(YYINITIAL);
                            }
<COMMENT_STATE> .|\n        {
                           }


<YYINITIAL>"<text>" {
                  // If it finds the ~start of textAtom~ label, it changes the
                  // state to TEXTATOM_STATE. In this state characters are
                  // readed until the end of textatom label "</text--->" is
                  // found.
                  yybegin(TEXTATOM_STATE);
                  // the buffer for the content is set to the empty string.
                  this.textContent.setLength(0);
                }


<TEXTATOM_STATE>"\\</text--->" {
                  this.textContent.append("</text--->");
}

<TEXTATOM_STATE>{double_bs} {
                  this.textContent.append("\\");
             }

<TEXTATOM_STATE> .|\n|\r {
                  // For any character, given that it has not detected the ~end
                  // of textatom~ label, the readed character belongs to the
                  // content of the textatom. So, it stores the character.
                  this.textContent.append(yytext());
                }

<TEXTATOM_STATE> "</text--->" {
                  // if it finds the ~end of textAtom~ label, it restores the
                  // state to the initial state (YYINITIAL) and returns the
                  // read string.
                    yybegin(YYINITIAL);
                String completeText =  this.textContent.toString();
                  // Erases the content of ~textContent~.
                      this.textContent.setLength(0);
                  return(new NLToken(NLToken.TT_TEXT_ATOM,
                         ListExpr.textAtom(completeText),
                         yychar+1, yyline+1));
}

<YYINITIAL>"'" { yybegin(TEXTATOM_SIMPLE);
                  this.textContent.setLength(0);
               }

<TEXTATOM_SIMPLE>{double_bs} {
                       this.textContent.append("\\");
}

<TEXTATOM_SIMPLE>[^']|\n|\r {
  this.textContent.append(yytext());
}

<TEXTATOM_SIMPLE>\\' {
  this.textContent.append("'");
}


<TEXTATOM_SIMPLE>"'" {
                    yybegin(YYINITIAL);
                    String completeText = this.textContent.toString();
                    this.textContent.setLength(0);
                    return(new NLToken(NLToken.TT_TEXT_ATOM,
                           ListExpr.textAtom(completeText),
                           yychar+1, yyline+1));
                }






<YYINITIAL> "(" {
                  // If it finds an OPEN_PAR token.
                  return(new NLToken(NLToken.TT_OPEN_PAR, null, yychar+1,
                         yyline+1));
                }

<YYINITIAL> ")" {
                  // If it finds a CLOSE_PAR token.
                  return(new NLToken(NLToken.TT_CLOSE_PAR, null, yychar+1,
                         yyline+1));
                }


<YYINITIAL>.  {
                  // If an unknown token is read.
                  if (NLTokenizer.DEBUG_MODE){
                    Reporter.writeError("DEBUG MODE: Error: Unknown token found when scanning the input in the NLTokenizer class.");
                    Reporter.writeError("The value is'"+yytext()+"'");
                  }
                  return (new NLToken(NLToken.error, null, yychar+1,
                          yyline+1));
                }

